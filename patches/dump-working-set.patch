diff --git a/Makefile b/Makefile
index 848cf0fc..b836ed09 100644
--- a/Makefile
+++ b/Makefile
@@ -81,7 +81,7 @@ export PROTOUFIX DEFINES
 DEFINES			+= -D_FILE_OFFSET_BITS=64
 DEFINES			+= -D_GNU_SOURCE
 
-WARNINGS		:= -Wall -Wformat-security
+WARNINGS		:= -Wall -Wformat-security -Wno-misleading-indentation -Wno-unused-result -Wno-unused-function
 
 CFLAGS-GCOV		:= --coverage -fno-exceptions -fno-inline
 export CFLAGS-GCOV
diff --git a/criu/mem.c b/criu/mem.c
index 230705a7..6bb49383 100644
--- a/criu/mem.c
+++ b/criu/mem.c
@@ -883,6 +883,8 @@ static int restore_priv_vma_content(struct pstree_item *t, struct page_read *pr)
 	unsigned int nr_lazy = 0;
 	unsigned long va;
 
+    struct pico_page_list *plhead = NULL;
+
 	if (opts.check_only) {
 		pr->close(pr);
 		return 0;
@@ -904,12 +906,33 @@ static int restore_priv_vma_content(struct pstree_item *t, struct page_read *pr)
 		va = (unsigned long)decode_pointer(pr->pe->vaddr);
 		nr_pages = pr->pe->nr_pages;
 
+        /*
+         * The lookup is over *all* possible VMAs
+         * read from image file.
+         */
+        while (va >= vma->e->end) {
+            if (vma->list.next == vmas)
+                goto err_addr;
+            vma = vma_next(vma);
+        }
+
 		/*
 		 * This means that userfaultfd is used to load the pages
 		 * on demand.
 		 */
 		if (opts.lazy_pages && pagemap_lazy(pr->pe)) {
 			pr_debug("Lazy restore skips %ld pages at %lx\n", nr_pages, va);
+
+            void *p;
+			off = (va - vma->e->start) / PAGE_SIZE;
+			p = decode_pointer((off) * PAGE_SIZE +
+					vma->premmaped_addr);
+            struct pico_page_list *pl = malloc(sizeof(struct pico_page_list));
+            pl->addr = (unsigned long)p;
+            pl->size = nr_pages * PAGE_SIZE;
+            pl->next = plhead;
+            plhead = pl;
+
 			pr->skip_pages(pr, nr_pages * PAGE_SIZE);
 			nr_lazy += nr_pages;
 			continue;
@@ -919,15 +942,15 @@ static int restore_priv_vma_content(struct pstree_item *t, struct page_read *pr)
 			unsigned char buf[PAGE_SIZE];
 			void *p;
 
-			/*
-			 * The lookup is over *all* possible VMAs
-			 * read from image file.
-			 */
-			while (va >= vma->e->end) {
-				if (vma->list.next == vmas)
-					goto err_addr;
-				vma = vma_next(vma);
-			}
+        /*
+         * The lookup is over *all* possible VMAs
+         * read from image file.
+         */
+        while (va >= vma->e->end) {
+            if (vma->list.next == vmas)
+                goto err_addr;
+            vma = vma_next(vma);
+        }
 
 			/*
 			 * Make sure the page address is inside existing VMA
@@ -1055,6 +1078,14 @@ err_read:
 		}
 	}
 
+    // madvise DONTNEED ALL PAGES THAT ARE SKIPPED
+    struct pico_page_list *pl;
+    for (pl=plhead; pl; pl=pl->next) {
+        if (madvise((void*)pl->addr, pl->size, MADV_DONTNEED))
+            pr_err("CONNOR: madvise");
+    }
+    pico_page_list_free(plhead);
+
 	cnt_add(CNT_PAGES_COMPARED, nr_compared);
 	cnt_add(CNT_PAGES_SKIPPED_COW, nr_shared);
 	cnt_add(CNT_PAGES_RESTORED, nr_restored);
diff --git a/criu/pico-cache.c b/criu/pico-cache.c
index 5e942c4d..b01ae2e9 100644
--- a/criu/pico-cache.c
+++ b/criu/pico-cache.c
@@ -1,6 +1,7 @@
 #include <sys/types.h>
 #include <sys/stat.h>
 #include <fcntl.h>
+#include <stdio.h>
 #include <stdlib.h>
 #include <unistd.h>
 
@@ -16,6 +17,68 @@
 static struct page_read pr = { 0 };
 static struct iovec ciov;
 static int page_read_set = 0;
+static unsigned long *ws_list = NULL;
+static int ws_i = 0;
+static size_t ws_n = 0;
+
+static void
+populate_wslist(int pid)
+{
+    char fn[20] = { 0 };
+    sprintf(fn, "/tmp/ws.%d", pid);
+
+    FILE *f = fopen(fn, "r");
+
+    // read number of elements, allocate mem
+    size_t i;
+    fscanf(f, "%lu", &ws_n);
+    ws_list = malloc(ws_n * sizeof(unsigned long));
+
+    // read elements
+    for (i=0; i<ws_n; i++) {
+        fscanf(f, "%lu", &ws_list[i]);
+    }
+
+    fclose(f);
+}
+
+static void
+free_wslist()
+{
+    free(ws_list);
+}
+
+static char
+next_ws_iov(struct iovec *iov, int *index, size_t n, unsigned long *ws_list, unsigned long limit)
+{
+    // scan to first address in iov
+    while (*index < n-1 &&
+            (void*)ws_list[*index] < iov->iov_base)
+        (*index)++;
+
+    // working set page is not in bounds
+    if ((void*)ws_list[*index] < iov->iov_base ||
+            ws_list[*index] >= limit) {
+        iov->iov_len = (void*)limit - iov->iov_base;
+        return 0;
+    }
+
+    // next working set page is ahead in bounds
+    if ((void*)ws_list[*index] > iov->iov_base) {
+        iov->iov_len = (void*)ws_list[*index] - iov->iov_base;
+        return 0;
+    }
+
+    // increment iov_len by 4096 for all consecutive pages
+    iov->iov_len = 0;
+    while (ws_list[*index] < limit &&
+            (void*)ws_list[*index] == iov->iov_base + iov->iov_len) {
+        iov->iov_len += PAGE_SIZE;
+        (*index)++;
+    }
+
+    return 1;
+}
 
 static void
 pico_reset_page_read()
@@ -29,6 +92,8 @@ pico_reset_page_read()
     pr.advance(&pr);
     ciov.iov_base = (void*)pr.pe->vaddr;
     ciov.iov_len = pr.pe->nr_pages * PAGE_SIZE;
+
+    ws_i = 0;
 }
 
 int
@@ -39,7 +104,7 @@ pico_page_xfer_dump_pages(struct page_xfer *xfer, struct page_pipe *pp,
     unsigned int cur_hole = 0;
     int ret;
 
-    struct iovec tmpiov, vmaiov;
+    struct iovec tmpiov, vmaiov, wsiov;
     vmaiov.iov_base = NULL;
     struct vma_area *vma = NULL;
     int dfd = -1;
@@ -60,6 +125,9 @@ pico_page_xfer_dump_pages(struct page_xfer *xfer, struct page_pipe *pp,
             return -1;
         close(dfd);
         pico_reset_page_read();
+
+        // open working set file, read into an array
+        populate_wslist(xfer->pid);
     }
     if (opts.pico_cache) {
         vma = list_entry(xfer->vma_area_list->h.next, typeof(*vma), list);
@@ -196,23 +264,43 @@ pico_page_xfer_dump_pages(struct page_xfer *xfer, struct page_pipe *pp,
 
                     tmpiov.iov_len = end - tmpiov.iov_base;
 
-                    if (ppb->flags & PPB_LAZY && !dump_lazy) {
-                        flags = PE_LAZY;
-                        //pr_debug("CONNOR: writing pagemap 0x%lx - 0x%lx\n", (long unsigned)tmpiov.iov_base, (long unsigned)tmpiov.iov_base + tmpiov.iov_len);
-                        if (xfer->write_pagemap(xfer, &tmpiov, flags, version, naddrs, addrs, port)) {
-                            return -1;
+                    wsiov.iov_base = tmpiov.iov_base;
+                    wsiov.iov_len = 0;
+                    char in_ws;
+
+                    pr_debug("tmpiov = %lx, %lx\n",
+                                        (unsigned long)tmpiov.iov_base,
+                                        (unsigned long)tmpiov.iov_len);
+
+                    while (wsiov.iov_base < end) {
+                        // compute next wsiov
+                        in_ws = 0;
+                        in_ws = next_ws_iov(&wsiov, &ws_i, ws_n, ws_list,
+                                        (unsigned long)tmpiov.iov_base+tmpiov.iov_len);
+                        pr_debug("wsiov  = %lx, %lx\n",
+                                        (unsigned long)wsiov.iov_base,
+                                        (unsigned long)wsiov.iov_len);
+
+                        if (ppb->flags & PPB_LAZY && !dump_lazy && !in_ws) {
+                            flags = PE_LAZY;
+                            //pr_debug("CONNOR: writing pagemap 0x%lx - 0x%lx\n", (long unsigned)tmpiov.iov_base, (long unsigned)tmpiov.iov_base + tmpiov.iov_len);
+                            if (xfer->write_pagemap(xfer, &wsiov, flags, version, naddrs, addrs, port)) {
+                                return -1;
+                            }
                         }
-                    }
-                    else if (ppb->flags & PPB_LAZY && dump_lazy) {
-                        flags |= PE_LAZY;
-                    }
-                    if (flags != PE_LAZY) {
-                        //pr_debug("CONNOR: writing pagemap 0x%lx - 0x%lx\n", (long unsigned)tmpiov.iov_base, (long unsigned)tmpiov.iov_base + tmpiov.iov_len);
-                        if (xfer->write_pagemap(xfer, &tmpiov, flags, version, naddrs, addrs, port)) {
-                            return -1;
+                        else if (ppb->flags & PPB_LAZY && dump_lazy) {
+                            //flags |= PE_LAZY;
                         }
-                        if (xfer->write_pages(xfer, ppb->p[0], tmpiov.iov_len))
-                            return -1;
+                        if (flags != PE_LAZY) {
+                            //pr_debug("CONNOR: writing pagemap 0x%lx - 0x%lx\n", (long unsigned)tmpiov.iov_base, (long unsigned)tmpiov.iov_base + tmpiov.iov_len);
+                            if (xfer->write_pagemap(xfer, &wsiov, flags, version, naddrs, addrs, port)) {
+                                return -1;
+                            }
+                            if (xfer->write_pages(xfer, ppb->p[0], wsiov.iov_len))
+                                return -1;
+                        }
+
+                        wsiov.iov_base = wsiov.iov_base + wsiov.iov_len;
                     }
 
                     if (free_addrs) {
@@ -306,4 +394,6 @@ pico_reset_pagemap_cache()
     // if multiple processes, will need to reopen a different pagemap cache
     page_read_set = 0;
     pr.close(&pr);
+
+    free_wslist();
 }
diff --git a/criu/pico-restore.c b/criu/pico-restore.c
index 27562340..c6e3eed1 100644
--- a/criu/pico-restore.c
+++ b/criu/pico-restore.c
@@ -257,6 +257,8 @@ pico_get_remote_pages(struct page_read *pr, long unsigned addr, int nr, void *bu
             .dst_id		= pr->pid,
         };
 
+        pr_debug("CONNOR: from %u:%d requesting %lx, %d\n", server->addr, server->sk, pi.vaddr, pi.nr_pages);
+
         //if (pico_soft_migrate(pico_addr, nr_pages))
         //    goto jail;
 
@@ -283,6 +285,14 @@ pico_get_remote_pages(struct page_read *pr, long unsigned addr, int nr, void *bu
         // copy pe into uffdio_copy
         if (read_page_complete(pr->pid, pl->addr, pl->size/PAGE_SIZE, pr))
             return -1;
+
+        /*pr_debug("CONNOR: pico-restore raw page data (%lu):\n", nr * PAGE_SIZE);
+        pr_debug("====================\n");
+        int logfd = log_get_fd();
+        int foo = write(logfd, pico_uffd_buf, total_recv);
+        if (foo < total_recv)
+            pr_debug("CONNOR: foo\n");
+        pr_debug("\n====================\n\n");*/
     }
     pr_debug("CONNOR: time after page read\n\n");
 
@@ -290,14 +300,6 @@ pico_get_remote_pages(struct page_read *pr, long unsigned addr, int nr, void *bu
 
     pico_page_list_free(plhead);
 
-    /*pr_debug("CONNOR: pico-restore raw page data (%lu):\n", nr * PAGE_SIZE);
-    pr_debug("====================\n");
-    int logfd = log_get_fd();
-    int foo = write(logfd, buf, nr * PAGE_SIZE);
-    if (foo < nr * PAGE_SIZE)
-        pr_debug("CONNOR: foo\n");
-    pr_debug("\n====================\n\n");*/
-
 //jail:
     return 0;
 }
diff --git a/criu/sockets.c b/criu/sockets.c
index 5915b39b..7e484d9a 100644
--- a/criu/sockets.c
+++ b/criu/sockets.c
@@ -642,14 +642,14 @@ int collect_sockets(struct ns_id *ns)
 	req.hdr.nlmsg_seq	= CR_NLMSG_SEQ;
 
 	/* Collect UNIX sockets */
-	req.r.u.sdiag_family	= AF_UNIX;
-	req.r.u.udiag_states	= -1; /* All */
-	req.r.u.udiag_show	= UDIAG_SHOW_NAME | UDIAG_SHOW_VFS |
-				  UDIAG_SHOW_PEER | UDIAG_SHOW_ICONS |
-				  UDIAG_SHOW_RQLEN;
-	tmp = do_collect_req(nl, &req, sizeof(req), unix_receive_one, ns, NULL);
-	if (tmp)
-		err = tmp;
+	//req.r.u.sdiag_family	= AF_UNIX;
+	//req.r.u.udiag_states	= -1; /* All */
+	//req.r.u.udiag_show	= UDIAG_SHOW_NAME | UDIAG_SHOW_VFS |
+	//			  UDIAG_SHOW_PEER | UDIAG_SHOW_ICONS |
+	//			  UDIAG_SHOW_RQLEN;
+	//tmp = do_collect_req(nl, &req, sizeof(req), unix_receive_one, ns, NULL);
+	//if (tmp)
+	//	err = tmp;
 
 	/* Collect IPv4 TCP sockets */
 	req.r.i.sdiag_family	= AF_INET;
